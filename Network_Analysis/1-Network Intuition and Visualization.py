

# Network Intuition and Visualization 


import matplotlib.pyplot as plt ## for plotting 
import seaborn as sns           ## for plotting 
import pandas as pd             ## manipulating dataframes
import numpy as np              ## useful structure and math functions

import networkx as nx # for network analysis
import bct # brain connectivity toolbox
    # Brain Connectivity Toolbox for python: https://github.com/aestrivex/bctpy 
    # Could also import brainconn ## it seems like they are changing bct to brianconn or it is separate but similar? 



num_nodes = len(ccx)
num_nodes

num_edges = np.count_nonzero(ccx)
num_edges

# Test Whether network is directed
  # function
    # this function takes a matrix and tests if and its transpose are element wise equal within the specified tolerance
      # note - I keep tolerance to the defaults but specify them here. 
def check_symmetric(a, rtol=1e-05, atol=1e-08):
    return np.allclose(a, a.T, rtol=rtol, atol=atol)

  # trying out the function 
not check_symmetric(ccx)  
isdirected = abs(not check_symmetric(ccx))
isdirected

#testing if network is binary
len(np.unique(np.array(ccx).nonzero()))>1
isweighted=abs(len(np.unique(np.array(ccx).nonzero()))>1)
isweighted

# calculate network density 
d = bct.density_dir(np.array(ccx))[0]
d
  ## calculate this manually 
d_manual = num_edges/(np.count_nonzero(np.eye(num_nodes)==0)) 
  ##> note we reverse by count_nonzero here by making a T/F matrix indicating 0
  ##> I cant find a count_zero function but thsi will do
d_manual

# Calculate degree sequence note that the choice of function again
  # Depends on whether your network is directed or not.
[degree_out, degree_in, degree_total] = bct.degrees_dir(ccx)

degree_in.head()
degree_out.head()
degree_total.head()

  # they want you to calculate manually but I am not going to do this 

# Network distribution 

# Calculate max degree
max_deg = max(degree_total)
          
# Create bins
bins = range(0,max_deg)

## note density = True normalizes the hist
plt.hist(degree_total,bins,density=True); plt.xlabel("total degree"); plt.ylabel("probability") ;plt.show(); plt.clf()

  ## could also do this
[x,bins,p]=plt.hist(degree_total,bins,density=True); plt.xlabel("total degree"); plt.ylabel("probability") 
    # get the normalized values 
h = x/sum(x) ## then you can plot these but I'm not going to do this 


# To binarize the network we set all connections with a weight above some 
# threshold equal to 1
thr = 1;
          
# Use threshold function
ccx_bin = (ccx >= thr).astype(int);


          
# To calculate path length and efficiency we first need to generate the 
# topological distance matrix.
D = bct.distance_bin(np.array(ccx_bin))
          
# Both measures are easily calculated using the characteristic path length 
# function
a = bct.charpath(D)
bct.charpath(D)[0]
path_length = a[0]
eff = a[1]

path_length
eff


# To contextualize these values, we compare them against an ensemble of networks 
  # that are similar to our original network but that differ along specific dimensions
  #> We do this with an 'edge swapping' algorithm, implemented in the function randmio_dir. 
  #> This function randomly swaps each edge 'iter' times. Generally, we want iter to be 
  #> large enough that the network generated by the function is sufficiently random. 
  #> Also, because we cannot compare against the entire space of networks with the 
  #> same degree sequence, we compare against a sample. 


# % Set some parameters
Num_samples = 100;
itera = 2^5;


# % Generate a new randomized network each time through the loop
  # initializing the lists
path_length_rand = []
eff_rand = []

for i in range(1,Num_samples):
  ccx_bin_rand = bct.randmio_dir(np.array(ccx_bin),itera)[0]
  D_rand = bct.distance_bin(ccx_bin_rand)
  path_length_rand.append(bct.charpath(D_rand)[0])
  eff_rand.append(bct.charpath(D_rand)[1])

# We can estimate the statistical significance of path length and efficiency
   # by comparing against our sample of the null distribution.
p_path_length = np.mean(np.array(path_length_rand))
p_eff = np.mean(np.array(eff_rand))


# % As an aside, you can confirm that the original and randomized networks
  # have identical degree sequences.
degree_in_rand = bct.degrees_dir(ccx_bin_rand)[0]
degree_out_rand = bct.degrees_dir(ccx_bin_rand)[1]
degree_total_rand = bct.degrees_dir(ccx_bin_rand)[2]


# plot the node degree in the original network versus the node degree in the randomized network. 
plt.scatter(degree_total,degree_total_rand); plt.xlabel('node degree in original network'); plt.ylabel('node degree in randomized network'); plt.show(); plt.clf()


import seaborn as sns

sns.heatmap(ccx, cmap= "viridis"); plt.xlabel('nodes (areas)'); plt.ylabel('nodes (areas)');plt.show(); plt.clf()



# ordering by degree total

idxsort = list(bct.grid_communities(degree_total.sort_index(ascending=False))[1])

sns.heatmap(ccx.reindex(index=idxsort,columns= idxsort), cmap= "viridis"); plt.xlabel('nodes (areas)'); plt.ylabel('nodes (areas)');plt.show(); plt.clf()



## ordering by lovain algorithm 

communities = bct.community_louvain(np.array(ccx))[0]
idxsort = list(bct.grid_communities(communities)[1])

sns.heatmap(ccx.reindex(index= idxsort,columns= idxsort), cmap= "viridis");plt.xlabel('nodes (areas)'); plt.ylabel('nodes (areas)');plt.show(); plt.clf()





from scipy.interpolate import interp1d

interp1d([min(degree_total),max(degree_total)],degree_total)

# Plotting networks. 

  # creating a directed graph - using a function 
    #> This function creates a directed graph using nx then 
      #> draws it usign the spring layout 
      #> coloring the edges blue
      #> coloring nodes usign the previously identified communities
      #> varies size of teh node using density calculated above *note we multiply by 50 to increase visability 
      #> sets the alpha for more transparency
      #> increases the edge size (aka arrow)

def show_digraph_with_labels(adjacency_matrix, mylabels):
    #rows, cols = np.where(adjacency_matrix >= 1)
    #edges = zip(rows.tolist(), cols.tolist())
    gr = nx.DiGraph(adjacency_matrix) ## could remove the adjacency matrix here and uncomment the sections above and below too
    #gr.add_edges_from(edges)
    nx.draw(gr, 
      labels=mylabels, 
      with_labels=True,
      pos=nx.spring_layout(gr),
      #can add these if you want 
      #node_size=500, ## you might want to open this if you leave these out to increase node size 
      edge_color = "Blue",     ## edge color
      node_color = communities,     ## node color ## could add an array with community detection here too
      node_size = [v * 50 for v in d.values()],  ## edge size based on degree
      alpha = 0.25,            ## transparancy
      arrowsize = 4)           ## size of arrow
    plt.show();plt.clf()

show_digraph_with_labels(ccx,None)

















